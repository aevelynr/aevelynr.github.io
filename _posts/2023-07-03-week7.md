---
layout: post
title: Week 7
---

## CS + X


## Study Skills and Belonging
Due to the Fourth of July holiday, the research team and I were unable to meet and share updates. I was able to code, here meaning identifying and flagging key words, two more transcripts. I felt like I was able to identify more key words than I was able to in the past due to the analysis I performed. In previous weeks, Deb has asked me to look into where our coding styles differed, and I found that I am more likely to use the "Self" code in places where the interviewee is not explicitly referencing themselves. I deduced that with my qualitative background, I have a tendency to read between the lines and draw conclusions; also, I remembered the voice of the interviewee from my time hand-correcting the A.I. generated transcripts, so I was drawing on the interviewee's tone of voice and cadence.

I was able to perform my first draft of the sentiment analysis on the hand-corrected interview texts. For reference, the data that I have access to is in a .csv format with the reference text, a rolled up list of Deb's codes, a rolled up list of my codes, the text Deb tagged, the text I tagged, and the "similarity" score. The similarity score is how Deb analyzed the differences in our codes and subcodes. Previously, I had uploaded, cleaned, and parsed the data into dataclasses called Code and Entry. Entry refers to each attribute of the data, and instead of a list of codes for Deb and I, I created a class called Code that hold the code, subcode, and note information for each tagged code. 

With all the data neatly sectioned, I was able to add a Sentiment class which held the reference text, sentiment (Very Negative, Negative, None, Positive, and Very Positive), and polarity (a float from -1 to 1). Using the TextBlob package, I was able to scan each reference text, calculate a polarity, and then assign a sentiment. Each Entry class has the Sentiment as an attribute. 

In addition, I needed to add a method to examine whether my code and Deb's code were equal. My logic was that if we tagged the same code and subcode for a reference text, those two codes are "identical" and can be used in a sentiment analysis. To handle 'nan' values, I added a try/except clause.

```
    def find_identical_code(self):
        identical = dict()

        for code in self.deb_codes:
            for code1 in self.angela_codes:
                try:
                    code.__eq__(code1)
                    identical[self.reference_text] = [code.code, code.subcode, self.sentiment.sentiment,
                                                      self.sentiment.polarity]
                except:
                    continue

with open("sentiment.csv", "w") as csvfile:
    w = csv.writer(csvfile)

    for entry in entries:
        # Build a dictionary of the member names and values...
        same = entry.find_identical_code()
        w.writerows(same.items())
```


## General Reflections
